============================= test session starts =============================
platform win32 -- Python 3.9.10, pytest-6.2.4, py-1.11.0, pluggy-0.13.1 -- C:\Users\btann\Documents\Dev\api_final_yatube\venv\Scripts\python.exe
django: settings: yatube_api.settings (from ini)
rootdir: C:\Users\btann\Documents\Dev\api_final_yatube, configfile: pytest.ini, testpaths: tests/
plugins: django-4.4.0, pythonpath-0.7.3
collecting ... collected 55 items

tests/test_comment.py::TestCommentAPI::test_comments_not_authenticated ERROR [  1%]
tests/test_comment.py::TestCommentAPI::test_comment_single_not_authenticated ERROR [  3%]
tests/test_comment.py::TestCommentAPI::test_comments_not_found ERROR     [  5%]
tests/test_comment.py::TestCommentAPI::test_comments_id_available ERROR  [  7%]
tests/test_comment.py::TestCommentAPI::test_comments_get ERROR           [  9%]
tests/test_comment.py::TestCommentAPI::test_comment_create_by_unauth ERROR [ 10%]
tests/test_comment.py::TestCommentAPI::test_comments_post_auth_with_valid_data ERROR [ 12%]
tests/test_comment.py::TestCommentAPI::test_comments_auth_post_with_invalid_data ERROR [ 14%]
tests/test_comment.py::TestCommentAPI::test_comment_author_and_post_are_read_only ERROR [ 16%]
tests/test_comment.py::TestCommentAPI::test_comment_id_auth_get ERROR    [ 18%]
tests/test_comment.py::TestCommentAPI::test_comment_change_by_auth_with_valid_data[put] ERROR [ 20%]
tests/test_comment.py::TestCommentAPI::test_comment_change_by_auth_with_valid_data[patch] ERROR [ 21%]
tests/test_comment.py::TestCommentAPI::test_comment_change_not_auth_with_valid_data[put] ERROR [ 23%]
tests/test_comment.py::TestCommentAPI::test_comment_change_not_auth_with_valid_data[patch] ERROR [ 25%]
tests/test_comment.py::TestCommentAPI::test_comment_delete_by_author ERROR [ 27%]
tests/test_comment.py::TestCommentAPI::test_comment_delete_by_not_author ERROR [ 29%]
tests/test_comment.py::TestCommentAPI::test_comment_delete_by_unauth ERROR [ 30%]
tests/test_follow.py::TestFollowAPI::test_follow_not_found PASSED        [ 32%]
tests/test_follow.py::TestFollowAPI::test_follow_not_auth PASSED         [ 34%]
tests/test_follow.py::TestFollowAPI::test_follow_get PASSED              [ 36%]
tests/test_follow.py::TestFollowAPI::test_follow_create PASSED           [ 38%]
tests/test_follow.py::TestFollowAPI::test_follow_search_filter PASSED    [ 40%]
tests/test_group.py::TestGroupAPI::test_group_not_found FAILED           [ 41%]
tests/test_group.py::TestGroupAPI::test_group_list_not_auth ERROR        [ 43%]
tests/test_group.py::TestGroupAPI::test_group_page_not_found FAILED      [ 45%]
tests/test_group.py::TestGroupAPI::test_group_single_not_auth FAILED     [ 47%]
tests/test_group.py::TestGroupAPI::test_group_auth_get FAILED            [ 49%]
tests/test_group.py::TestGroupAPI::test_group_create PASSED              [ 50%]
tests/test_group.py::TestGroupAPI::test_group_page_auth_get FAILED       [ 52%]
tests/test_jwt.py::TestJWT::test_jwt_create__invalid_request_data PASSED [ 54%]
tests/test_jwt.py::TestJWT::test_jwt_create__valid_request_data PASSED   [ 56%]
tests/test_jwt.py::TestJWT::test_jwt_refresh__invalid_request_data PASSED [ 58%]
tests/test_jwt.py::TestJWT::test_jwt_refresh__valid_request_data PASSED  [ 60%]
tests/test_jwt.py::TestJWT::test_jwt_verify__invalid_request_data PASSED [ 61%]
tests/test_jwt.py::TestJWT::test_jwt_verify__valid_request_data PASSED   [ 63%]
tests/test_post.py::TestPostAPI::test_post_not_found ERROR               [ 65%]
tests/test_post.py::TestPostAPI::test_post_list_not_auth ERROR           [ 67%]
tests/test_post.py::TestPostAPI::test_post_single_not_auth ERROR         [ 69%]
tests/test_post.py::TestPostAPI::test_posts_auth_get ERROR               [ 70%]
tests/test_post.py::TestPostAPI::test_posts_get_paginated ERROR          [ 72%]
tests/test_post.py::TestPostAPI::test_post_create_auth_with_invalid_data PASSED [ 74%]
tests/test_post.py::TestPostAPI::test_post_create_auth_with_valid_data FAILED [ 76%]
tests/test_post.py::TestPostAPI::test_post_unauth_create PASSED          [ 78%]
tests/test_post.py::TestPostAPI::test_post_get_current ERROR             [ 80%]
tests/test_post.py::TestPostAPI::test_post_change_auth_with_valid_data[put] ERROR [ 81%]
tests/test_post.py::TestPostAPI::test_post_change_auth_with_valid_data[patch] ERROR [ 83%]
tests/test_post.py::TestPostAPI::test_post_change_not_auth_with_valid_data[put] ERROR [ 85%]
tests/test_post.py::TestPostAPI::test_post_change_not_auth_with_valid_data[patch] ERROR [ 87%]
tests/test_post.py::TestPostAPI::test_post_change_not_author_with_valid_data[put] ERROR [ 89%]
tests/test_post.py::TestPostAPI::test_post_change_not_author_with_valid_data[patch] ERROR [ 90%]
tests/test_post.py::TestPostAPI::test_post_patch_auth_with_invalid_data[put] ERROR [ 92%]
tests/test_post.py::TestPostAPI::test_post_patch_auth_with_invalid_data[patch] ERROR [ 94%]
tests/test_post.py::TestPostAPI::test_post_delete_by_author ERROR        [ 96%]
tests/test_post.py::TestPostAPI::test_post_delete_not_author ERROR       [ 98%]
tests/test_post.py::TestPostAPI::test_post_unauth_delete_current ERROR   [100%]

=================================== ERRORS ====================================
______ ERROR at setup of TestCommentAPI.test_comments_not_authenticated _______

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEB9310F10>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
---------------------------- Captured stdout setup ----------------------------
Operations to perform:
  Synchronize unmigrated apps: api, django_filters, djoser, messages, rest_framework, staticfiles
  Apply all migrations: admin, auth, contenttypes, posts, sessions
Synchronizing apps without migrations:
  Creating tables...
    Running deferred SQL...
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying posts.0001_initial... OK
  Applying posts.0002_auto_20230505_2244... OK
  Applying sessions.0001_initial... OK
---------------------------- Captured stderr setup ----------------------------
Creating test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
___ ERROR at setup of TestCommentAPI.test_comment_single_not_authenticated ____

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEB95C41F0>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
__________ ERROR at setup of TestCommentAPI.test_comments_not_found ___________

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEB9546070>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_________ ERROR at setup of TestCommentAPI.test_comments_id_available _________

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEB9364280>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_____________ ERROR at setup of TestCommentAPI.test_comments_get ______________

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBA9950A0>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_______ ERROR at setup of TestCommentAPI.test_comment_create_by_unauth ________

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBA981850>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
__ ERROR at setup of TestCommentAPI.test_comments_post_auth_with_valid_data ___

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEB93FD940>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_ ERROR at setup of TestCommentAPI.test_comments_auth_post_with_invalid_data __

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEB9382EE0>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_ ERROR at setup of TestCommentAPI.test_comment_author_and_post_are_read_only _

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBAA7E580>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
__________ ERROR at setup of TestCommentAPI.test_comment_id_auth_get __________

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEB9364160>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_ ERROR at setup of TestCommentAPI.test_comment_change_by_auth_with_valid_data[put] _

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBA8548B0>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_ ERROR at setup of TestCommentAPI.test_comment_change_by_auth_with_valid_data[patch] _

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBA8DED90>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_ ERROR at setup of TestCommentAPI.test_comment_change_not_auth_with_valid_data[put] _

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBA77DC70>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_ ERROR at setup of TestCommentAPI.test_comment_change_not_auth_with_valid_data[patch] _

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBA684970>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_______ ERROR at setup of TestCommentAPI.test_comment_delete_by_author ________

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBA78B820>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_____ ERROR at setup of TestCommentAPI.test_comment_delete_by_not_author ______

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEB933AFD0>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_______ ERROR at setup of TestCommentAPI.test_comment_delete_by_unauth ________

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBA87A580>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
___________ ERROR at setup of TestGroupAPI.test_group_list_not_auth ___________

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBAC70D30>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
______________ ERROR at setup of TestPostAPI.test_post_not_found ______________

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBAB9D760>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
____________ ERROR at setup of TestPostAPI.test_post_list_not_auth ____________

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBAC2CDF0>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
___________ ERROR at setup of TestPostAPI.test_post_single_not_auth ___________

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBACDA670>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
______________ ERROR at setup of TestPostAPI.test_posts_auth_get ______________

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBB092880>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
___________ ERROR at setup of TestPostAPI.test_posts_get_paginated ____________

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBAB9D6D0>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_____________ ERROR at setup of TestPostAPI.test_post_get_current _____________

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBAC93F40>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
__ ERROR at setup of TestPostAPI.test_post_change_auth_with_valid_data[put] ___

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBAA426D0>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_ ERROR at setup of TestPostAPI.test_post_change_auth_with_valid_data[patch] __

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBAEEEBE0>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_ ERROR at setup of TestPostAPI.test_post_change_not_auth_with_valid_data[put] _

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBAF2D280>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_ ERROR at setup of TestPostAPI.test_post_change_not_auth_with_valid_data[patch] _

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBAE67310>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_ ERROR at setup of TestPostAPI.test_post_change_not_author_with_valid_data[put] _

another_user = <User: TestUserAnother>, group_2 = <Group: Группа 2>

    @pytest.fixture
    def another_post(another_user, group_2):
>       return Post.objects.create(
            text='Тестовый пост 2', author=another_user, group=group_2
        )

tests\fixtures\fixture_data.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 2>, args = (), kwargs = {'group': <Group: Группа 2>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBAE41790>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUserAnother>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_ ERROR at setup of TestPostAPI.test_post_change_not_author_with_valid_data[patch] _

another_user = <User: TestUserAnother>, group_2 = <Group: Группа 2>

    @pytest.fixture
    def another_post(another_user, group_2):
>       return Post.objects.create(
            text='Тестовый пост 2', author=another_user, group=group_2
        )

tests\fixtures\fixture_data.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 2>, args = (), kwargs = {'group': <Group: Группа 2>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBA6785B0>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUserAnother>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
__ ERROR at setup of TestPostAPI.test_post_patch_auth_with_invalid_data[put] __

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBAC8EC10>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
_ ERROR at setup of TestPostAPI.test_post_patch_auth_with_invalid_data[patch] _

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBABE4A00>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
__________ ERROR at setup of TestPostAPI.test_post_delete_by_author ___________

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBAB81910>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
__________ ERROR at setup of TestPostAPI.test_post_delete_not_author __________

another_user = <User: TestUserAnother>, group_2 = <Group: Группа 2>

    @pytest.fixture
    def another_post(another_user, group_2):
>       return Post.objects.create(
            text='Тестовый пост 2', author=another_user, group=group_2
        )

tests\fixtures\fixture_data.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 2>, args = (), kwargs = {'group': <Group: Группа 2>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBAE656D0>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUserAnother>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
________ ERROR at setup of TestPostAPI.test_post_unauth_delete_current ________

user = <User: TestUser>, group_1 = <Group: Группа 1>

    @pytest.fixture
    def post(user, group_1):
>       return Post.objects.create(
            text='Тестовый пост 1', author=user, group=group_1
        )

tests\fixtures\fixture_data.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\db\models\manager.py:85: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
venv\lib\site-packages\django\db\models\query.py:451: in create
    obj = self.model(**kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Тестовый пост 1>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBAEEB6D0>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError
================================== FAILURES ===================================
______________________ TestGroupAPI.test_group_not_found ______________________

self = <tests.test_group.TestGroupAPI object at 0x000001BEBA83F6A0>
client = <django.test.client.Client object at 0x000001BEBA83FE80>
group_1 = <Group: Группа 1>

    def test_group_not_found(self, client, group_1):
>       response = client.get(self.group_url)

tests\test_group.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\test\client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv\lib\site-packages\django\test\client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv\lib\site-packages\django\test\client.py:473: in generic
    return self.request(**r)
venv\lib\site-packages\django\test\client.py:719: in request
    self.check_exception(response)
venv\lib\site-packages\django\test\client.py:580: in check_exception
    raise exc_value
venv\lib\site-packages\django\core\handlers\exception.py:47: in inner
    response = get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:181: in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
venv\lib\site-packages\django\views\decorators\csrf.py:54: in wrapped_view
    return view_func(*args, **kwargs)
venv\lib\site-packages\rest_framework\viewsets.py:125: in view
    return self.dispatch(request, *args, **kwargs)
venv\lib\site-packages\rest_framework\views.py:509: in dispatch
    response = self.handle_exception(exc)
venv\lib\site-packages\rest_framework\views.py:469: in handle_exception
    self.raise_uncaught_exception(exc)
venv\lib\site-packages\rest_framework\views.py:480: in raise_uncaught_exception
    raise exc
venv\lib\site-packages\rest_framework\views.py:506: in dispatch
    response = handler(request, *args, **kwargs)
venv\lib\site-packages\rest_framework\mixins.py:46: in list
    return Response(serializer.data)
venv\lib\site-packages\rest_framework\serializers.py:745: in data
    ret = super().data
venv\lib\site-packages\rest_framework\serializers.py:246: in data
    self._data = self.to_representation(self.instance)
venv\lib\site-packages\rest_framework\serializers.py:663: in to_representation
    return [
venv\lib\site-packages\rest_framework\serializers.py:664: in <listcomp>
    self.child.to_representation(item) for item in iterable
venv\lib\site-packages\rest_framework\serializers.py:502: in to_representation
    attribute = field.get_attribute(instance)
venv\lib\site-packages\rest_framework\relations.py:538: in get_attribute
    relationship = get_attribute(instance, self.source_attrs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

instance = <Group: Группа 1>, attrs = ['posts']

    def get_attribute(instance, attrs):
        """
        Similar to Python's built in `getattr(instance, attr)`,
        but takes a list of nested attributes, instead of a single attribute.
    
        Also accepts either attribute lookup on objects or dictionary lookups.
        """
        for attr in attrs:
            try:
                if isinstance(instance, Mapping):
                    instance = instance[attr]
                else:
>                   instance = getattr(instance, attr)
E                   AttributeError: 'Group' object has no attribute 'posts'

venv\lib\site-packages\rest_framework\fields.py:97: AttributeError
------------------------------ Captured log call ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /api/v1/groups/
Traceback (most recent call last):
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\views\decorators\csrf.py", line 54, in wrapped_view
    return view_func(*args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\viewsets.py", line 125, in view
    return self.dispatch(request, *args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 509, in dispatch
    response = self.handle_exception(exc)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 469, in handle_exception
    self.raise_uncaught_exception(exc)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 480, in raise_uncaught_exception
    raise exc
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 506, in dispatch
    response = handler(request, *args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\mixins.py", line 46, in list
    return Response(serializer.data)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 745, in data
    ret = super().data
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 246, in data
    self._data = self.to_representation(self.instance)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 663, in to_representation
    return [
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 664, in <listcomp>
    self.child.to_representation(item) for item in iterable
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 502, in to_representation
    attribute = field.get_attribute(instance)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\relations.py", line 538, in get_attribute
    relationship = get_attribute(instance, self.source_attrs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\fields.py", line 97, in get_attribute
    instance = getattr(instance, attr)
AttributeError: 'Group' object has no attribute 'posts'
___________________ TestGroupAPI.test_group_page_not_found ____________________

self = <tests.test_group.TestGroupAPI object at 0x000001BEBA9B7EB0>
client = <django.test.client.Client object at 0x000001BEBAE41B50>
group_1 = <Group: Группа 1>

    def test_group_page_not_found(self, client, group_1):
>       response = client.get(
            self.group_detail_url.format(group_id=group_1.id)
        )

tests\test_group.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\test\client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv\lib\site-packages\django\test\client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv\lib\site-packages\django\test\client.py:473: in generic
    return self.request(**r)
venv\lib\site-packages\django\test\client.py:719: in request
    self.check_exception(response)
venv\lib\site-packages\django\test\client.py:580: in check_exception
    raise exc_value
venv\lib\site-packages\django\core\handlers\exception.py:47: in inner
    response = get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:181: in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
venv\lib\site-packages\django\views\decorators\csrf.py:54: in wrapped_view
    return view_func(*args, **kwargs)
venv\lib\site-packages\rest_framework\viewsets.py:125: in view
    return self.dispatch(request, *args, **kwargs)
venv\lib\site-packages\rest_framework\views.py:509: in dispatch
    response = self.handle_exception(exc)
venv\lib\site-packages\rest_framework\views.py:469: in handle_exception
    self.raise_uncaught_exception(exc)
venv\lib\site-packages\rest_framework\views.py:480: in raise_uncaught_exception
    raise exc
venv\lib\site-packages\rest_framework\views.py:506: in dispatch
    response = handler(request, *args, **kwargs)
venv\lib\site-packages\rest_framework\mixins.py:56: in retrieve
    return Response(serializer.data)
venv\lib\site-packages\rest_framework\serializers.py:548: in data
    ret = super().data
venv\lib\site-packages\rest_framework\serializers.py:246: in data
    self._data = self.to_representation(self.instance)
venv\lib\site-packages\rest_framework\serializers.py:502: in to_representation
    attribute = field.get_attribute(instance)
venv\lib\site-packages\rest_framework\relations.py:538: in get_attribute
    relationship = get_attribute(instance, self.source_attrs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

instance = <Group: Группа 1>, attrs = ['posts']

    def get_attribute(instance, attrs):
        """
        Similar to Python's built in `getattr(instance, attr)`,
        but takes a list of nested attributes, instead of a single attribute.
    
        Also accepts either attribute lookup on objects or dictionary lookups.
        """
        for attr in attrs:
            try:
                if isinstance(instance, Mapping):
                    instance = instance[attr]
                else:
>                   instance = getattr(instance, attr)
E                   AttributeError: 'Group' object has no attribute 'posts'

venv\lib\site-packages\rest_framework\fields.py:97: AttributeError
------------------------------ Captured log call ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /api/v1/groups/20/
Traceback (most recent call last):
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\views\decorators\csrf.py", line 54, in wrapped_view
    return view_func(*args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\viewsets.py", line 125, in view
    return self.dispatch(request, *args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 509, in dispatch
    response = self.handle_exception(exc)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 469, in handle_exception
    self.raise_uncaught_exception(exc)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 480, in raise_uncaught_exception
    raise exc
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 506, in dispatch
    response = handler(request, *args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\mixins.py", line 56, in retrieve
    return Response(serializer.data)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 548, in data
    ret = super().data
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 246, in data
    self._data = self.to_representation(self.instance)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 502, in to_representation
    attribute = field.get_attribute(instance)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\relations.py", line 538, in get_attribute
    relationship = get_attribute(instance, self.source_attrs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\fields.py", line 97, in get_attribute
    instance = getattr(instance, attr)
AttributeError: 'Group' object has no attribute 'posts'
___________________ TestGroupAPI.test_group_single_not_auth ___________________

self = <tests.test_group.TestGroupAPI object at 0x000001BEBAC76A60>
client = <django.test.client.Client object at 0x000001BEBABE2370>
group_1 = <Group: Группа 1>

    def test_group_single_not_auth(self, client, group_1):
>       response = client.get(
            self.group_detail_url.format(group_id=group_1.id)
        )

tests\test_group.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\django\test\client.py:742: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv\lib\site-packages\django\test\client.py:396: in get
    return self.generic('GET', path, secure=secure, **{
venv\lib\site-packages\django\test\client.py:473: in generic
    return self.request(**r)
venv\lib\site-packages\django\test\client.py:719: in request
    self.check_exception(response)
venv\lib\site-packages\django\test\client.py:580: in check_exception
    raise exc_value
venv\lib\site-packages\django\core\handlers\exception.py:47: in inner
    response = get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:181: in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
venv\lib\site-packages\django\views\decorators\csrf.py:54: in wrapped_view
    return view_func(*args, **kwargs)
venv\lib\site-packages\rest_framework\viewsets.py:125: in view
    return self.dispatch(request, *args, **kwargs)
venv\lib\site-packages\rest_framework\views.py:509: in dispatch
    response = self.handle_exception(exc)
venv\lib\site-packages\rest_framework\views.py:469: in handle_exception
    self.raise_uncaught_exception(exc)
venv\lib\site-packages\rest_framework\views.py:480: in raise_uncaught_exception
    raise exc
venv\lib\site-packages\rest_framework\views.py:506: in dispatch
    response = handler(request, *args, **kwargs)
venv\lib\site-packages\rest_framework\mixins.py:56: in retrieve
    return Response(serializer.data)
venv\lib\site-packages\rest_framework\serializers.py:548: in data
    ret = super().data
venv\lib\site-packages\rest_framework\serializers.py:246: in data
    self._data = self.to_representation(self.instance)
venv\lib\site-packages\rest_framework\serializers.py:502: in to_representation
    attribute = field.get_attribute(instance)
venv\lib\site-packages\rest_framework\relations.py:538: in get_attribute
    relationship = get_attribute(instance, self.source_attrs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

instance = <Group: Группа 1>, attrs = ['posts']

    def get_attribute(instance, attrs):
        """
        Similar to Python's built in `getattr(instance, attr)`,
        but takes a list of nested attributes, instead of a single attribute.
    
        Also accepts either attribute lookup on objects or dictionary lookups.
        """
        for attr in attrs:
            try:
                if isinstance(instance, Mapping):
                    instance = instance[attr]
                else:
>                   instance = getattr(instance, attr)
E                   AttributeError: 'Group' object has no attribute 'posts'

venv\lib\site-packages\rest_framework\fields.py:97: AttributeError
------------------------------ Captured log call ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /api/v1/groups/21/
Traceback (most recent call last):
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\views\decorators\csrf.py", line 54, in wrapped_view
    return view_func(*args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\viewsets.py", line 125, in view
    return self.dispatch(request, *args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 509, in dispatch
    response = self.handle_exception(exc)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 469, in handle_exception
    self.raise_uncaught_exception(exc)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 480, in raise_uncaught_exception
    raise exc
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 506, in dispatch
    response = handler(request, *args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\mixins.py", line 56, in retrieve
    return Response(serializer.data)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 548, in data
    ret = super().data
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 246, in data
    self._data = self.to_representation(self.instance)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 502, in to_representation
    attribute = field.get_attribute(instance)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\relations.py", line 538, in get_attribute
    relationship = get_attribute(instance, self.source_attrs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\fields.py", line 97, in get_attribute
    instance = getattr(instance, attr)
AttributeError: 'Group' object has no attribute 'posts'
______________________ TestGroupAPI.test_group_auth_get _______________________

self = <tests.test_group.TestGroupAPI object at 0x000001BEBA6888B0>
user_client = <rest_framework.test.APIClient object at 0x000001BEBAC9A3D0>
group_1 = <Group: Группа 1>, group_2 = <Group: Группа 2>

    def test_group_auth_get(self, user_client, group_1, group_2):
>       response = user_client.get(self.group_url)

tests\test_group.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\rest_framework\test.py:288: in get
    response = super().get(path, data=data, **extra)
venv\lib\site-packages\rest_framework\test.py:205: in get
    return self.generic('GET', path, **r)
venv\lib\site-packages\rest_framework\test.py:233: in generic
    return super().generic(
venv\lib\site-packages\django\test\client.py:473: in generic
    return self.request(**r)
venv\lib\site-packages\rest_framework\test.py:285: in request
    return super().request(**kwargs)
venv\lib\site-packages\rest_framework\test.py:237: in request
    request = super().request(**kwargs)
venv\lib\site-packages\django\test\client.py:719: in request
    self.check_exception(response)
venv\lib\site-packages\django\test\client.py:580: in check_exception
    raise exc_value
venv\lib\site-packages\django\core\handlers\exception.py:47: in inner
    response = get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:181: in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
venv\lib\site-packages\django\views\decorators\csrf.py:54: in wrapped_view
    return view_func(*args, **kwargs)
venv\lib\site-packages\rest_framework\viewsets.py:125: in view
    return self.dispatch(request, *args, **kwargs)
venv\lib\site-packages\rest_framework\views.py:509: in dispatch
    response = self.handle_exception(exc)
venv\lib\site-packages\rest_framework\views.py:469: in handle_exception
    self.raise_uncaught_exception(exc)
venv\lib\site-packages\rest_framework\views.py:480: in raise_uncaught_exception
    raise exc
venv\lib\site-packages\rest_framework\views.py:506: in dispatch
    response = handler(request, *args, **kwargs)
venv\lib\site-packages\rest_framework\mixins.py:46: in list
    return Response(serializer.data)
venv\lib\site-packages\rest_framework\serializers.py:745: in data
    ret = super().data
venv\lib\site-packages\rest_framework\serializers.py:246: in data
    self._data = self.to_representation(self.instance)
venv\lib\site-packages\rest_framework\serializers.py:663: in to_representation
    return [
venv\lib\site-packages\rest_framework\serializers.py:664: in <listcomp>
    self.child.to_representation(item) for item in iterable
venv\lib\site-packages\rest_framework\serializers.py:502: in to_representation
    attribute = field.get_attribute(instance)
venv\lib\site-packages\rest_framework\relations.py:538: in get_attribute
    relationship = get_attribute(instance, self.source_attrs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

instance = <Group: Группа 1>, attrs = ['posts']

    def get_attribute(instance, attrs):
        """
        Similar to Python's built in `getattr(instance, attr)`,
        but takes a list of nested attributes, instead of a single attribute.
    
        Also accepts either attribute lookup on objects or dictionary lookups.
        """
        for attr in attrs:
            try:
                if isinstance(instance, Mapping):
                    instance = instance[attr]
                else:
>                   instance = getattr(instance, attr)
E                   AttributeError: 'Group' object has no attribute 'posts'

venv\lib\site-packages\rest_framework\fields.py:97: AttributeError
------------------------------ Captured log call ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /api/v1/groups/
Traceback (most recent call last):
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\views\decorators\csrf.py", line 54, in wrapped_view
    return view_func(*args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\viewsets.py", line 125, in view
    return self.dispatch(request, *args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 509, in dispatch
    response = self.handle_exception(exc)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 469, in handle_exception
    self.raise_uncaught_exception(exc)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 480, in raise_uncaught_exception
    raise exc
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 506, in dispatch
    response = handler(request, *args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\mixins.py", line 46, in list
    return Response(serializer.data)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 745, in data
    ret = super().data
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 246, in data
    self._data = self.to_representation(self.instance)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 663, in to_representation
    return [
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 664, in <listcomp>
    self.child.to_representation(item) for item in iterable
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 502, in to_representation
    attribute = field.get_attribute(instance)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\relations.py", line 538, in get_attribute
    relationship = get_attribute(instance, self.source_attrs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\fields.py", line 97, in get_attribute
    instance = getattr(instance, attr)
AttributeError: 'Group' object has no attribute 'posts'
____________________ TestGroupAPI.test_group_page_auth_get ____________________

self = <tests.test_group.TestGroupAPI object at 0x000001BEBA853580>
user_client = <rest_framework.test.APIClient object at 0x000001BEBA9B7400>
group_1 = <Group: Группа 1>

    def test_group_page_auth_get(self, user_client, group_1):
>       response = user_client.get(
            self.group_detail_url.format(group_id=group_1.id)
        )

tests\test_group.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\rest_framework\test.py:288: in get
    response = super().get(path, data=data, **extra)
venv\lib\site-packages\rest_framework\test.py:205: in get
    return self.generic('GET', path, **r)
venv\lib\site-packages\rest_framework\test.py:233: in generic
    return super().generic(
venv\lib\site-packages\django\test\client.py:473: in generic
    return self.request(**r)
venv\lib\site-packages\rest_framework\test.py:285: in request
    return super().request(**kwargs)
venv\lib\site-packages\rest_framework\test.py:237: in request
    request = super().request(**kwargs)
venv\lib\site-packages\django\test\client.py:719: in request
    self.check_exception(response)
venv\lib\site-packages\django\test\client.py:580: in check_exception
    raise exc_value
venv\lib\site-packages\django\core\handlers\exception.py:47: in inner
    response = get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:181: in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
venv\lib\site-packages\django\views\decorators\csrf.py:54: in wrapped_view
    return view_func(*args, **kwargs)
venv\lib\site-packages\rest_framework\viewsets.py:125: in view
    return self.dispatch(request, *args, **kwargs)
venv\lib\site-packages\rest_framework\views.py:509: in dispatch
    response = self.handle_exception(exc)
venv\lib\site-packages\rest_framework\views.py:469: in handle_exception
    self.raise_uncaught_exception(exc)
venv\lib\site-packages\rest_framework\views.py:480: in raise_uncaught_exception
    raise exc
venv\lib\site-packages\rest_framework\views.py:506: in dispatch
    response = handler(request, *args, **kwargs)
venv\lib\site-packages\rest_framework\mixins.py:56: in retrieve
    return Response(serializer.data)
venv\lib\site-packages\rest_framework\serializers.py:548: in data
    ret = super().data
venv\lib\site-packages\rest_framework\serializers.py:246: in data
    self._data = self.to_representation(self.instance)
venv\lib\site-packages\rest_framework\serializers.py:502: in to_representation
    attribute = field.get_attribute(instance)
venv\lib\site-packages\rest_framework\relations.py:538: in get_attribute
    relationship = get_attribute(instance, self.source_attrs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

instance = <Group: Группа 1>, attrs = ['posts']

    def get_attribute(instance, attrs):
        """
        Similar to Python's built in `getattr(instance, attr)`,
        but takes a list of nested attributes, instead of a single attribute.
    
        Also accepts either attribute lookup on objects or dictionary lookups.
        """
        for attr in attrs:
            try:
                if isinstance(instance, Mapping):
                    instance = instance[attr]
                else:
>                   instance = getattr(instance, attr)
E                   AttributeError: 'Group' object has no attribute 'posts'

venv\lib\site-packages\rest_framework\fields.py:97: AttributeError
------------------------------ Captured log call ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /api/v1/groups/26/
Traceback (most recent call last):
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\views\decorators\csrf.py", line 54, in wrapped_view
    return view_func(*args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\viewsets.py", line 125, in view
    return self.dispatch(request, *args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 509, in dispatch
    response = self.handle_exception(exc)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 469, in handle_exception
    self.raise_uncaught_exception(exc)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 480, in raise_uncaught_exception
    raise exc
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 506, in dispatch
    response = handler(request, *args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\mixins.py", line 56, in retrieve
    return Response(serializer.data)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 548, in data
    ret = super().data
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 246, in data
    self._data = self.to_representation(self.instance)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 502, in to_representation
    attribute = field.get_attribute(instance)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\relations.py", line 538, in get_attribute
    relationship = get_attribute(instance, self.source_attrs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\fields.py", line 97, in get_attribute
    instance = getattr(instance, attr)
AttributeError: 'Group' object has no attribute 'posts'
______________ TestPostAPI.test_post_create_auth_with_valid_data ______________

self = PostSerializer(context={'request': <rest_framework.request.Request: POST '/api/v1/posts/'>, 'format': None, 'view': <a...d(queryset=<QuerySet [<Group: Группа 1>]>, required=False)
    comments = StringRelatedField(many=True, read_only=True)
validated_data = {'author': <User: TestUser>, 'group': <Group: Группа 1>, 'text': 'Статья номер 3'}

    def create(self, validated_data):
        """
        We have a bit of extra checking around this in order to provide
        descriptive messages when something goes wrong, but this method is
        essentially just:
    
            return ExampleModel.objects.create(**validated_data)
    
        If there are many to many fields present on the instance then they
        cannot be set until the model is instantiated, in which case the
        implementation is like so:
    
            example_relationship = validated_data.pop('example_relationship')
            instance = ExampleModel.objects.create(**validated_data)
            instance.example_relationship = example_relationship
            return instance
    
        The default implementation also does not handle nested relationships.
        If you want to support writable nested relationships you'll need
        to write an explicit `.create()` method.
        """
        raise_errors_on_nested_writes('create', self, validated_data)
    
        ModelClass = self.Meta.model
    
        # Remove many-to-many relationships from validated_data.
        # They are not valid arguments to the default `.create()` method,
        # as they require that the instance has already been saved.
        info = model_meta.get_field_info(ModelClass)
        many_to_many = {}
        for field_name, relation_info in info.relations.items():
            if relation_info.to_many and (field_name in validated_data):
                many_to_many[field_name] = validated_data.pop(field_name)
    
        try:
>           instance = ModelClass._default_manager.create(**validated_data)

venv\lib\site-packages\rest_framework\serializers.py:939: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.db.models.manager.Manager object at 0x000001BEB937BA60>
args = ()
kwargs = {'author': <User: TestUser>, 'group': <Group: Группа 1>, 'text': 'Статья номер 3'}

    def manager_method(self, *args, **kwargs):
>       return getattr(self.get_queryset(), name)(*args, **kwargs)

venv\lib\site-packages\django\db\models\manager.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <QuerySet []>
kwargs = {'author': <User: TestUser>, 'group': <Group: Группа 1>, 'text': 'Статья номер 3'}

    def create(self, **kwargs):
        """
        Create a new object with the given kwargs, saving it to the database
        and returning the created object.
        """
>       obj = self.model(**kwargs)

venv\lib\site-packages\django\db\models\query.py:451: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Post: Статья номер 3>, args = (), kwargs = {'group': <Group: Группа 1>}
cls = <class 'posts.models.Post'>, opts = <Options for Post>
_setattr = <built-in function setattr>, _DEFERRED = <Deferred field>
fields_iter = <tuple_iterator object at 0x000001BEBAB819D0>, val = None
field = <django.db.models.fields.files.ImageField: image>
is_related_object = False, rel_obj = <User: TestUser>
property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError('Abstract models cannot be instantiated.')
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) > len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                kwargs.pop(field.name, None)
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.attname not in kwargs and field.column is None:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            for prop in tuple(kwargs):
                try:
                    # Any remaining kwargs must correspond to properties or
                    # virtual fields.
                    if prop in property_names or opts.get_field(prop):
                        if kwargs[prop] is not _DEFERRED:
                            _setattr(self, prop, kwargs[prop])
                        del kwargs[prop]
                except (AttributeError, FieldDoesNotExist):
                    pass
            for kwarg in kwargs:
>               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E               TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\django\db\models\base.py:503: TypeError

During handling of the above exception, another exception occurred:

self = <tests.test_post.TestPostAPI object at 0x000001BEBAECE070>
user_client = <rest_framework.test.APIClient object at 0x000001BEBAE455E0>
user = <User: TestUser>, group_1 = <Group: Группа 1>

    def test_post_create_auth_with_valid_data(self, user_client, user,
                                              group_1):
        post_count = Post.objects.count()
    
        assert_msg = (
            'Проверьте, что для авторизованного пользователя  POST-запрос с '
            f'корректными данными к `{self.post_list_url}` возвращает ответ '
            'со статусом 201.'
        )
        data = {'text': 'Статья номер 3', 'group': group_1.id}
        try:
>           response = user_client.post(self.post_list_url, data=data)

tests\test_post.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\lib\site-packages\rest_framework\test.py:295: in post
    response = super().post(
venv\lib\site-packages\rest_framework\test.py:209: in post
    return self.generic('POST', path, data, content_type, **extra)
venv\lib\site-packages\rest_framework\test.py:233: in generic
    return super().generic(
venv\lib\site-packages\django\test\client.py:473: in generic
    return self.request(**r)
venv\lib\site-packages\rest_framework\test.py:285: in request
    return super().request(**kwargs)
venv\lib\site-packages\rest_framework\test.py:237: in request
    request = super().request(**kwargs)
venv\lib\site-packages\django\test\client.py:719: in request
    self.check_exception(response)
venv\lib\site-packages\django\test\client.py:580: in check_exception
    raise exc_value
venv\lib\site-packages\django\core\handlers\exception.py:47: in inner
    response = get_response(request)
venv\lib\site-packages\django\core\handlers\base.py:181: in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
venv\lib\site-packages\django\views\decorators\csrf.py:54: in wrapped_view
    return view_func(*args, **kwargs)
venv\lib\site-packages\rest_framework\viewsets.py:125: in view
    return self.dispatch(request, *args, **kwargs)
venv\lib\site-packages\rest_framework\views.py:509: in dispatch
    response = self.handle_exception(exc)
venv\lib\site-packages\rest_framework\views.py:469: in handle_exception
    self.raise_uncaught_exception(exc)
venv\lib\site-packages\rest_framework\views.py:480: in raise_uncaught_exception
    raise exc
venv\lib\site-packages\rest_framework\views.py:506: in dispatch
    response = handler(request, *args, **kwargs)
venv\lib\site-packages\rest_framework\mixins.py:19: in create
    self.perform_create(serializer)
yatube_api\api\views.py:27: in perform_create
    serializer.save(author=self.request.user)
venv\lib\site-packages\rest_framework\serializers.py:205: in save
    self.instance = self.create(validated_data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = PostSerializer(context={'request': <rest_framework.request.Request: POST '/api/v1/posts/'>, 'format': None, 'view': <a...d(queryset=<QuerySet [<Group: Группа 1>]>, required=False)
    comments = StringRelatedField(many=True, read_only=True)
validated_data = {'author': <User: TestUser>, 'group': <Group: Группа 1>, 'text': 'Статья номер 3'}

    def create(self, validated_data):
        """
        We have a bit of extra checking around this in order to provide
        descriptive messages when something goes wrong, but this method is
        essentially just:
    
            return ExampleModel.objects.create(**validated_data)
    
        If there are many to many fields present on the instance then they
        cannot be set until the model is instantiated, in which case the
        implementation is like so:
    
            example_relationship = validated_data.pop('example_relationship')
            instance = ExampleModel.objects.create(**validated_data)
            instance.example_relationship = example_relationship
            return instance
    
        The default implementation also does not handle nested relationships.
        If you want to support writable nested relationships you'll need
        to write an explicit `.create()` method.
        """
        raise_errors_on_nested_writes('create', self, validated_data)
    
        ModelClass = self.Meta.model
    
        # Remove many-to-many relationships from validated_data.
        # They are not valid arguments to the default `.create()` method,
        # as they require that the instance has already been saved.
        info = model_meta.get_field_info(ModelClass)
        many_to_many = {}
        for field_name, relation_info in info.relations.items():
            if relation_info.to_many and (field_name in validated_data):
                many_to_many[field_name] = validated_data.pop(field_name)
    
        try:
            instance = ModelClass._default_manager.create(**validated_data)
        except TypeError:
            tb = traceback.format_exc()
            msg = (
                'Got a `TypeError` when calling `%s.%s.create()`. '
                'This may be because you have a writable field on the '
                'serializer class that is not a valid argument to '
                '`%s.%s.create()`. You may need to make the field '
                'read-only, or override the %s.create() method to handle '
                'this correctly.\nOriginal exception was:\n %s' %
                (
                    ModelClass.__name__,
                    ModelClass._default_manager.name,
                    ModelClass.__name__,
                    ModelClass._default_manager.name,
                    self.__class__.__name__,
                    tb
                )
            )
>           raise TypeError(msg)
E           TypeError: Got a `TypeError` when calling `Post.objects.create()`. This may be because you have a writable field on the serializer class that is not a valid argument to `Post.objects.create()`. You may need to make the field read-only, or override the PostSerializer.create() method to handle this correctly.
E           Original exception was:
E            Traceback (most recent call last):
E             File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 939, in create
E               instance = ModelClass._default_manager.create(**validated_data)
E             File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\db\models\manager.py", line 85, in manager_method
E               return getattr(self.get_queryset(), name)(*args, **kwargs)
E             File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\db\models\query.py", line 451, in create
E               obj = self.model(**kwargs)
E             File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\db\models\base.py", line 503, in __init__
E               raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
E           TypeError: Post() got an unexpected keyword argument 'group'

venv\lib\site-packages\rest_framework\serializers.py:958: TypeError
------------------------------ Captured log call ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /api/v1/posts/
Traceback (most recent call last):
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 939, in create
    instance = ModelClass._default_manager.create(**validated_data)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\db\models\manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\db\models\query.py", line 451, in create
    obj = self.model(**kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\db\models\base.py", line 503, in __init__
    raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
TypeError: Post() got an unexpected keyword argument 'group'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\views\decorators\csrf.py", line 54, in wrapped_view
    return view_func(*args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\viewsets.py", line 125, in view
    return self.dispatch(request, *args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 509, in dispatch
    response = self.handle_exception(exc)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 469, in handle_exception
    self.raise_uncaught_exception(exc)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 480, in raise_uncaught_exception
    raise exc
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\views.py", line 506, in dispatch
    response = handler(request, *args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\mixins.py", line 19, in create
    self.perform_create(serializer)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\yatube_api\api\views.py", line 27, in perform_create
    serializer.save(author=self.request.user)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 205, in save
    self.instance = self.create(validated_data)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 958, in create
    raise TypeError(msg)
TypeError: Got a `TypeError` when calling `Post.objects.create()`. This may be because you have a writable field on the serializer class that is not a valid argument to `Post.objects.create()`. You may need to make the field read-only, or override the PostSerializer.create() method to handle this correctly.
Original exception was:
 Traceback (most recent call last):
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\rest_framework\serializers.py", line 939, in create
    instance = ModelClass._default_manager.create(**validated_data)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\db\models\manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\db\models\query.py", line 451, in create
    obj = self.model(**kwargs)
  File "C:\Users\btann\Documents\Dev\api_final_yatube\venv\lib\site-packages\django\db\models\base.py", line 503, in __init__
    raise TypeError("%s() got an unexpected keyword argument '%s'" % (cls.__name__, kwarg))
TypeError: Post() got an unexpected keyword argument 'group'
=========================== short test summary info ===========================
FAILED tests/test_group.py::TestGroupAPI::test_group_not_found - AttributeErr...
FAILED tests/test_group.py::TestGroupAPI::test_group_page_not_found - Attribu...
FAILED tests/test_group.py::TestGroupAPI::test_group_single_not_auth - Attrib...
FAILED tests/test_group.py::TestGroupAPI::test_group_auth_get - AttributeErro...
FAILED tests/test_group.py::TestGroupAPI::test_group_page_auth_get - Attribut...
FAILED tests/test_post.py::TestPostAPI::test_post_create_auth_with_valid_data
ERROR tests/test_comment.py::TestCommentAPI::test_comments_not_authenticated
ERROR tests/test_comment.py::TestCommentAPI::test_comment_single_not_authenticated
ERROR tests/test_comment.py::TestCommentAPI::test_comments_not_found - TypeEr...
ERROR tests/test_comment.py::TestCommentAPI::test_comments_id_available - Typ...
ERROR tests/test_comment.py::TestCommentAPI::test_comments_get - TypeError: P...
ERROR tests/test_comment.py::TestCommentAPI::test_comment_create_by_unauth - ...
ERROR tests/test_comment.py::TestCommentAPI::test_comments_post_auth_with_valid_data
ERROR tests/test_comment.py::TestCommentAPI::test_comments_auth_post_with_invalid_data
ERROR tests/test_comment.py::TestCommentAPI::test_comment_author_and_post_are_read_only
ERROR tests/test_comment.py::TestCommentAPI::test_comment_id_auth_get - TypeE...
ERROR tests/test_comment.py::TestCommentAPI::test_comment_change_by_auth_with_valid_data[put]
ERROR tests/test_comment.py::TestCommentAPI::test_comment_change_by_auth_with_valid_data[patch]
ERROR tests/test_comment.py::TestCommentAPI::test_comment_change_not_auth_with_valid_data[put]
ERROR tests/test_comment.py::TestCommentAPI::test_comment_change_not_auth_with_valid_data[patch]
ERROR tests/test_comment.py::TestCommentAPI::test_comment_delete_by_author - ...
ERROR tests/test_comment.py::TestCommentAPI::test_comment_delete_by_not_author
ERROR tests/test_comment.py::TestCommentAPI::test_comment_delete_by_unauth - ...
ERROR tests/test_group.py::TestGroupAPI::test_group_list_not_auth - TypeError...
ERROR tests/test_post.py::TestPostAPI::test_post_not_found - TypeError: Post(...
ERROR tests/test_post.py::TestPostAPI::test_post_list_not_auth - TypeError: P...
ERROR tests/test_post.py::TestPostAPI::test_post_single_not_auth - TypeError:...
ERROR tests/test_post.py::TestPostAPI::test_posts_auth_get - TypeError: Post(...
ERROR tests/test_post.py::TestPostAPI::test_posts_get_paginated - TypeError: ...
ERROR tests/test_post.py::TestPostAPI::test_post_get_current - TypeError: Pos...
ERROR tests/test_post.py::TestPostAPI::test_post_change_auth_with_valid_data[put]
ERROR tests/test_post.py::TestPostAPI::test_post_change_auth_with_valid_data[patch]
ERROR tests/test_post.py::TestPostAPI::test_post_change_not_auth_with_valid_data[put]
ERROR tests/test_post.py::TestPostAPI::test_post_change_not_auth_with_valid_data[patch]
ERROR tests/test_post.py::TestPostAPI::test_post_change_not_author_with_valid_data[put]
ERROR tests/test_post.py::TestPostAPI::test_post_change_not_author_with_valid_data[patch]
ERROR tests/test_post.py::TestPostAPI::test_post_patch_auth_with_invalid_data[put]
ERROR tests/test_post.py::TestPostAPI::test_post_patch_auth_with_invalid_data[patch]
ERROR tests/test_post.py::TestPostAPI::test_post_delete_by_author - TypeError...
ERROR tests/test_post.py::TestPostAPI::test_post_delete_not_author - TypeErro...
ERROR tests/test_post.py::TestPostAPI::test_post_unauth_delete_current - Type...
================== 6 failed, 14 passed, 35 errors in 17.15s ===================
